#!/usr/bin/env bash

# Set a reasonable umask and turn off aliases that may interfere with the operation of the script:

umask 022
unalias -a

#die() { echo ">>> $@"; exit 1; }
die() { echo -e "\033[1;31m>>> \033[0m$@"; exit 1; }
#einfo() { echo ">>> $@"; }
einfo() { echo -e "\033[1;32m>>> \033[0m$@"; }

if ! [ -r "$1" ]; then
	die "Please specify ebuild filename."
elif [ -z "$2" ]; then
	die "Please specify an action to perform."
fi

source_file() {
	# look for and source a file in the current directory if it exists; otherwise, look for it in its offical
	# canonical location (if provided as absolute path) and source it. Die if the file is not found.
	for fn in "$@"
	do
		local cwdfn="${fn##*/}"
		if [ -r "${cwdfn}" ]; then
			source "${cwdfn}"
		elif [ "${fn:0:1}" = "/" ] && [ -r "${fn}" ]; then
			source "${fn}"
		else
			die "File $fn (or local equivalent) not found. Exiting."
		fi
	done
}

source_file /usr/share/portage/config/make.globals
source_file ebuild.conf
export DISTDIR

if [ -z "${MAKEOPTS}" ]; then
	processors_num="$(grep -c '^processor' /proc/cpuinfo)" 
	MAKEOPTS="--jobs=$(( ${processors_num} + 1))"
fi

export MAKEOPTS

try() {
	# Wonder if it will be all right with double quotes.
	einfo "$@"
	if ! "$@"; then
		die "Error running command: $@";
	fi
}

pkg_setup() {
	return
}

src_clean() {
	if [ -d "${WORKDIR}" ]; then
		einfo "Cleaning old sources ..."
		rm -rf "${WORKDIR}"
	fi
	install -d "${WORKDIR}"; cd "${WORKDIR}"
}

src_fetch() {
	# Check is we already have sources downloaded.
	# todo: need checksum check or something.
	for source in "${sources[@]}"; do
		if ! [ -f "${DISTDIR}/${source##*/}" ]; then
			case "${source}" in
				http://*|https://*)
					einfo "Fetching ${source##*/} ..."
					wget "${source}" -O "${DISTDIR}/${source##*/}"
					if ! [ -s "${DISTDIR}/${source##*/}" ]; then
						rm -f "${DISTDIR}/${source##*/}"
						die "Unable to fetch ${source##*/}."
					fi
				;;
				*)
					die "You have to provide '${source##*/}'."
				;;
			esac
		fi
	done; unset source
}

src_unpack() {
	for source in "${sources[@]}"; do
		if ! [ -f "${DISTDIR}/${source##*/}" ]; then die "Missing source '${source##*/}'."; fi

		case "${source##*/}" in
			*.tar|*.tar.bz2|*.tar.xz|*.tar.gz|l*.tar.lzma)
				einfo "Extracting ${DISTDIR}/"${source##*/}" ..."
				try tar xf "${DISTDIR}/${source##*/}" -C "${WORKDIR}"
			;;
			*)
				die "Unsupported format."
			;;
		esac
	done; unset source

	# I think we should pre-create $S with package name and version and use '--strip-components 1' to tar.
	# So we can unpack multiple sources file into one $S.
	[ ! -d "$S" ] && die "Source directory $S specified in \$S does not exist. Exiting."
	
	# We should cd into $S before src_configure is done or ebuild will fail when we override src_configure with an ebuild.
	# like into e2fsprogs-1.18.ebuild.
	cd "$S"
}

src_compile() {
	einfo "Compiling source ..."
	# Shoudn't we drop MAKEOPTS in favor of MAKEFLAGS variable which make use by default?
	cd "$S"; try make "$MAKEOPTS"
}

src_configure() {
	einfo "Configuring source ..."
	cd "$S"; [ -e ./configure ] && try econf
}

src_install() {
	einfo "Installing into '$IMAGEDIR' ..."
	cd "$S"; try make DESTDIR="$IMAGEDIR" install
}

econf() {
	./configure \
		--prefix=/usr \
		--mandir=/usr/share/man \
		--infodir=/usr/share/info \
		--datadir=/usr/share \
		--sysconfdir=/etc \
		--localstatedir=/var/lib \
		--disable-dependency-tracking \
		"$@"
}

P="${1%.ebuild}"
PV="${P##*-}"
PN="${P%-*}"
ORIGDIR=$(pwd)
IMAGEDIR=${ORIGDIR}/temp/$P/image
export WORKDIR=${ORIGDIR}/temp/$P/work
S=$WORKDIR/$P

source_file "$1"

pkg_setup

case "${2}" in
	clean)
		src_clean
		;;
	fetch)
		src_fetch
		;;
	unpack)
		src_clean
		src_fetch
		src_unpack
		;;
	configure)
		src_clean
		src_fetch
		src_unpack
		src_configure
		;;
	compile)
		src_clean
		src_fetch
		src_unpack
		src_configure
		src_compile
		;;
	install|all)
		src_clean
		src_fetch
		src_unpack
		src_configure
		src_compile
		src_install
		;;
	*)
		die "Please specify unpack, configure, compile or all as the second arg"
		;;
esac
